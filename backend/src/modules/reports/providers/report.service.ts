import { Injectable, Logger, ConflictException, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, In } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import moment from 'moment-timezone';
import { DailyReport } from '../entities/report.entity';
import { Order } from '../../orders/entities/order.entity';
import { OrderToken } from '../../order-tokens/entities/order-token.entity';
import { Expenses } from '../../expenses/entities/expenses.entity';
import { Customer } from '../../customers/entities/customer.entity';
import { Table } from '../../table/entities/table.entity';
import { Item } from '../../items/entities/item.entity';
import { DailyReportResponseDto } from '../dto/report-response.dto';
import { TokenType } from '../../order-tokens/enum/TokenType.enum';
import { CacheService } from 'src/modules/cache/cache.service';

@Injectable()
export class ReportService {
    private readonly logger = new Logger(ReportService.name);

    constructor(
        @InjectRepository(DailyReport)
        private readonly dailyReportRepository: Repository<DailyReport>,
        @InjectRepository(Order)
        private readonly orderRepository: Repository<Order>,
        @InjectRepository(OrderToken)
        private readonly orderTokenRepository: Repository<OrderToken>,
        @InjectRepository(Expenses)
        private readonly expensesRepository: Repository<Expenses>,
        @InjectRepository(Customer)
        private readonly customerRepository: Repository<Customer>,
        @InjectRepository(Table)
        private readonly tableRepository: Repository<Table>,
        @InjectRepository(Item)
        private readonly itemRepository: Repository<Item>,
        private readonly cacheService: CacheService,
    ) {}

    async generateReport(reportDate?: string, isAutoGenerated: boolean = false): Promise<DailyReportResponseDto> {
        const targetDate = reportDate || moment().tz('Asia/Dhaka').format('YYYY-MM-DD');

        if (reportDate && !moment(targetDate, 'YYYY-MM-DD', true).isValid()) {
            throw new BadRequestException(`Invalid date format: ${targetDate}. Expected YYYY-MM-DD`);
        }
        
        const existingReport = await this.dailyReportRepository.findOne({
            where: { report_date: new Date(targetDate) }
        });
    
        if (existingReport) {
            throw new ConflictException(`Daily report for ${targetDate} already exists`);
        }
    
        const startOfDay = moment.tz(targetDate, 'Asia/Dhaka').startOf('day').toDate();
        const endOfDay = moment.tz(targetDate, 'Asia/Dhaka').endOf('day').toDate();
        
        const ordersData = await this.getOrdersData(startOfDay, endOfDay);
        const expensesData = await this.getExpensesData(startOfDay, endOfDay);
        const creditAmount = ordersData.totalSales - expensesData.totalExpenses;
    
        const dailyReport = this.dailyReportRepository.create({
            report_date: new Date(targetDate),
            total_sales: ordersData.totalSales,
            bar_sales: ordersData.barSales,
            kitchen_sales: ordersData.kitchenSales,
            total_orders: ordersData.totalOrders,
            bar_orders: ordersData.barOrders,
            kitchen_orders: ordersData.kitchenOrders,
            total_expenses: expensesData.totalExpenses,
            total_expense_items: expensesData.totalExpenseItems,
            credit_amount: creditAmount,
            is_auto_generated: isAutoGenerated,
            generated_at: new Date(),
        });
    
        const savedReport = await this.dailyReportRepository.save(dailyReport);
        
        await this.invalidateReportCaches();
        
        return new DailyReportResponseDto(savedReport);
    }

    private async getOrdersData(startOfDay: Date, endOfDay: Date) {
        const orders = await this.orderRepository.find({
            where: {
                created_at: Between(startOfDay, endOfDay)
            },
            relations: ['orderTokens']
        });
        
        const orderTokens = await this.orderTokenRepository.find({
            where: {
                createdAt: Between(startOfDay, endOfDay)
            },
            relations: ['order', 'order_items']
        });
    
        const totalSales = orders.reduce((sum, order) => sum + Number(order.total_amount), 0);
        
        let barSales = 0;
        let kitchenSales = 0;
        let barOrders = 0;
        let kitchenOrders = 0;

        const barTokens = orderTokens.filter(token => token.token_type === TokenType.BAR);
        const kitchenTokens = orderTokens.filter(token => token.token_type === TokenType.KITCHEN);

        barOrders = barTokens.length;
        kitchenOrders = kitchenTokens.length;

        barSales = barTokens.reduce((sum, token) => {
            const tokenSales = token.order_items.reduce((itemSum, item) => itemSum + Number(item.total_price), 0);
            return sum + tokenSales;
        }, 0);

        kitchenSales = kitchenTokens.reduce((sum, token) => {
            const tokenSales = token.order_items.reduce((itemSum, item) => itemSum + Number(item.total_price), 0);
            return sum + tokenSales;
        }, 0);

        return {
            totalSales,
            barSales,
            kitchenSales,
            totalOrders: orders.length,
            barOrders,
            kitchenOrders
        };
    }

    // private async getExpensesData(startOfDay: Date, endOfDay: Date) {
    //     const expenses = await this.expensesRepository.find({
    //         where: {
    //             created_at: Between(startOfDay, endOfDay)
    //         }
    //     });

    //     const totalExpenses = expenses.reduce((sum, expense) => sum + Number(expense.amount), 0);
    //     const totalExpenseItems = expenses.length;

    //     return {
    //         totalExpenses,
    //         totalExpenseItems
    //     };
    // }

    private async getExpensesData(startOfDay: Date, endOfDay: Date) {
        const expenses = await this.expensesRepository.find({
            where: {
                created_at: Between(startOfDay, endOfDay),
                category: {
                    slug: 'daily-expense'
                }
            },
            relations: ['category']
        });

        const totalExpenses = expenses.reduce((sum, expense) => sum + Number(expense.amount), 0);
        const totalExpenseItems = expenses.length;

        return {
            totalExpenses,
            totalExpenseItems
        };
    }

    async findAll(page: number = 1, limit: number = 10): Promise<{
        data: DailyReportResponseDto[],
        total: number,
        page: number,
        limit: number,
        totalPages: number
    }> {
        const cacheKey = `reports:findAll:${page}:${limit}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached as {
                data: DailyReportResponseDto[],
                total: number,
                page: number,
                limit: number,
                totalPages: number
            };
        }

        const skip = (page - 1) * limit;
        const [reports, total] = await this.dailyReportRepository.findAndCount({
            order: { report_date: 'DESC' },
            skip,
            take: limit
        });

        const totalPages = Math.ceil(total / limit);
        const result = {
            data: reports.map(report => new DailyReportResponseDto(report)),
            total,
            page,
            limit,
            totalPages
        };
        
        await this.cacheService.set(cacheKey, result, 3600);
        return result;
    }

    async findOne(id: string): Promise<DailyReportResponseDto> {
        const cacheKey = `reports:findOne:${id}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached as DailyReportResponseDto;
        }

        const report = await this.dailyReportRepository.findOne({ where: { id } });
        if (!report) {
            throw new NotFoundException('Daily report not found');
        }
        
        const result = new DailyReportResponseDto(report);
        await this.cacheService.set(cacheKey, result, 3600);
        return result;
    }

    async findByDate(date: string): Promise<DailyReportResponseDto> {
        const cacheKey = `reports:findByDate:${date}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached as DailyReportResponseDto;
        }

        const report = await this.dailyReportRepository.findOne({
            where: { report_date: new Date(date) }
        });
        if (!report) {
            throw new NotFoundException(`Daily report for ${date} not found`);
        }
        
        const result = new DailyReportResponseDto(report);
        await this.cacheService.set(cacheKey, result, 3600);
        return result;
    }

    async regenerateReport(reportDate: string): Promise<DailyReportResponseDto> {
        if (!moment(reportDate, 'YYYY-MM-DD', true).isValid()) {
            throw new BadRequestException(`Invalid date format: ${reportDate}. Expected YYYY-MM-DD`);
        }
        await this.dailyReportRepository.delete({ report_date: new Date(reportDate) });
        await this.invalidateReportCaches();
        return await this.generateReport(reportDate, false);
    }

    async remove(id: string): Promise<{ deleted: boolean }> {
        const result = await this.dailyReportRepository.delete(id);
        if (result.affected === 0) {
            throw new NotFoundException('Daily report not found');
        }
        
        await this.invalidateReportCaches();
        return { deleted: true };
    }

    async getOverallFinancialSummary(): Promise<{
        total_sales: number;
        total_expenses: number;
        total_credit: number;
        current_fund: number;
        total_orders: number;
        total_expense_items: number;
        bar_sales: number;
        kitchen_sales: number;
        summary_date: Date;
    }> {
        const allOrders = await this.orderRepository.find({
            relations: ['orderTokens']
        });

        const allOrderTokens = await this.orderTokenRepository.find({
            relations: ['order', 'order_items']
        });

        const allExpenses = await this.expensesRepository.find();
        const totalSales = allOrders.reduce((sum, order) => sum + Number(order.total_amount), 0);
        const barTokens = allOrderTokens.filter(token => token.token_type === TokenType.BAR);
        const kitchenTokens = allOrderTokens.filter(token => token.token_type === TokenType.KITCHEN);

        const barSales = barTokens.reduce((sum, token) => {
            const tokenSales = token.order_items.reduce((itemSum, item) => itemSum + Number(item.total_price), 0);
            return sum + tokenSales;
        }, 0);

        const kitchenSales = kitchenTokens.reduce((sum, token) => {
            const tokenSales = token.order_items.reduce((itemSum, item) => itemSum + Number(item.total_price), 0);
            return sum + tokenSales;
        }, 0);

        const totalExpenses = allExpenses.reduce((sum, expense) => sum + Number(expense.amount), 0);
        const totalCredit = totalSales;
        const currentFund = totalSales - totalExpenses;

        const result = {
            total_sales: totalSales,
            total_expenses: totalExpenses,
            total_credit: totalCredit,
            current_fund: currentFund,
            total_orders: allOrders.length,
            total_expense_items: allExpenses.length,
            bar_sales: barSales,
            kitchen_sales: kitchenSales,
            summary_date: new Date()
        };
        
        const cacheKey = 'financial-summary';
        await this.cacheService.set(cacheKey, result, 3600);
        return result;
    }

    async getDashboardMetrics(): Promise<{
        todays_total_sales: number;
        active_orders: number;
        todays_expenses: number;
        pending_orders: number;
        takeaway_orders: number;
        dinein_orders: number;
        completed_orders: number;
        cancelled_orders: number;
        todays_profit: number;
        total_orders_today: number;
        average_order_value: number;
        total_customers: number;
        total_active_customers: number;
        total_tables: number;
        total_items: number;
        total_sales_reports: number;
        generated_at: Date;
    }> {
        const today = moment().tz('Asia/Dhaka').startOf('day').toDate();
        const endOfToday = moment().tz('Asia/Dhaka').endOf('day').toDate();
    
        const todaysOrders = await this.orderRepository.find({
            where: {
                created_at: Between(today, endOfToday)
            },
            relations: ['orderItems']
        });
    
        const activeOrders = await this.orderRepository.count({
            where: {
                status: In(['PENDING', 'PREPARING']),
                created_at: Between(today, endOfToday)
            }
        });
    
        const todaysExpenses = await this.expensesRepository.find({
            where: {
                created_at: Between(today, endOfToday)
            }
        });
    
        const totalCustomers = await this.customerRepository.count();
        const totalActiveCustomers = await this.customerRepository.count({ where: { is_active: true }});
        const totalTables = await this.tableRepository.count();
        const totalItems = await this.itemRepository.count();
        const totalSalesReports = await this.dailyReportRepository.count();
    
        const todaysTotalSales = todaysOrders.filter(order => order.status === 'COMPLETED').reduce((sum, order) => sum + Number(order.total_amount || 0), 0);
        const todaysExpensesTotal = todaysExpenses.reduce((sum, expense) => sum + Number(expense.amount || 0), 0);
        const pendingOrders = todaysOrders.filter(order => order.status === 'PENDING').length;
        const takeawayOrders = todaysOrders.filter(order => order.order_type === 'TAKEAWAY').length;
        const dineinOrders = todaysOrders.filter(order => order.order_type === 'DINEIN').length;
        const completedOrders = todaysOrders.filter(order => order.status === 'COMPLETED').length;
        const cancelledOrders = todaysOrders.filter(order => order.status === 'CANCELLED').length;
        const todaysProfit = todaysTotalSales - todaysExpensesTotal;
        const totalOrdersToday = todaysOrders.length;
        const averageOrderValue = totalOrdersToday > 0 ? todaysTotalSales / completedOrders : 0;
    
        return {
            todays_total_sales: todaysTotalSales,
            active_orders: activeOrders,
            todays_expenses: todaysExpensesTotal,
            pending_orders: pendingOrders,
            takeaway_orders: takeawayOrders,
            dinein_orders: dineinOrders,
            completed_orders: completedOrders,
            cancelled_orders: cancelledOrders,
            todays_profit: todaysProfit,
            total_orders_today: totalOrdersToday,
            average_order_value: averageOrderValue,
            total_customers: totalCustomers,
            total_active_customers: totalActiveCustomers,
            total_tables: totalTables,
            total_items: totalItems,
            total_sales_reports: totalSalesReports,
            generated_at: moment().tz('Asia/Dhaka').toDate()
        };
    }

    async getFilteredReportsWithSummary(
        filterType?: 'month' | 'year' | 'custom',
        filterValue?: string,
        startDate?: string,
        endDate?: string
    ): Promise<any> {
        const cacheKey = `reports:filteredReportsWithSummary:${filterType}:${filterValue}:${startDate}:${endDate}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached;
        }

        let whereCondition: any = {};
        let periodLabel: string;

        if (filterType === 'custom' && startDate && endDate) {
            const start = moment(startDate).startOf('day').toDate();
            const end = moment(endDate).endOf('day').toDate();
            whereCondition = {
                report_date: Between(start, end)
            };
            periodLabel = `${startDate} to ${endDate}`;
        } else if (filterType === 'year' && filterValue) {
            const start = moment(filterValue, 'YYYY').startOf('year').toDate();
            const end = moment(filterValue, 'YYYY').endOf('year').toDate();
            whereCondition = {
                report_date: Between(start, end)
            };
            periodLabel = filterValue;
        } else if (filterType === 'month' && filterValue) {
            const start = moment(filterValue, 'YYYY-MM').startOf('month').toDate();
            const end = moment(filterValue, 'YYYY-MM').endOf('month').toDate();
            whereCondition = {
                report_date: Between(start, end)
            };
            periodLabel = filterValue;
        } else {
            const start = moment().startOf('month').toDate();
            const end = moment().endOf('month').toDate();
            whereCondition = {
                report_date: Between(start, end)
            };
            periodLabel = moment().format('YYYY-MM');
        }

        const reports = await this.dailyReportRepository.find({
            where: whereCondition,
            order: { report_date: 'DESC' }
        });

        const totalSales = reports.reduce((sum, report) => sum + Number(report.total_sales), 0);
        const totalExpenses = reports.reduce((sum, report) => sum + Number(report.total_expenses), 0);
        const totalProfit = totalSales - totalExpenses;
        const totalOrders = reports.reduce((sum, report) => sum + Number(report.total_orders), 0);
        const totalDays = reports.length;
        const averageDailySales = totalDays > 0 ? totalSales / totalDays : 0;
        const averageDailyOrders = totalDays > 0 ? totalOrders / totalDays : 0;

        const bestSalesDay = reports.reduce((best, current) => 
            Number(current.total_sales) > Number(best.total_sales) ? current : best, 
            reports[0] || { total_sales: 0, report_date: new Date() }
        );

        const worstSalesDay = reports.reduce((worst, current) => 
            Number(current.total_sales) < Number(worst.total_sales) ? current : worst, 
            reports[0] || { total_sales: 0, report_date: new Date() }
        );

        let increasingDays = 0;
        let decreasingDays = 0;
        let stableDays = 0;

        for (let i = 1; i < reports.length; i++) {
            const current = Number(reports[i].total_sales);
            const previous = Number(reports[i - 1].total_sales);
            
            if (current > previous) {
                increasingDays++;
            } else if (current < previous) {
                decreasingDays++;
            } else {
                stableDays++;
            }
        }

        const result = {
            reports: reports.map(report => new DailyReportResponseDto(report)),
            summary: {
                period: periodLabel,
                total_sales: totalSales,
                total_expenses: totalExpenses,
                total_profit: totalProfit,
                total_orders: totalOrders,
                total_days: totalDays,
                average_daily_sales: averageDailySales,
                average_daily_orders: averageDailyOrders,
                best_sales_day: {
                    date: moment(bestSalesDay.report_date).format('YYYY-MM-DD'),
                    amount: Number(bestSalesDay.total_sales)
                },
                worst_sales_day: {
                    date: moment(worstSalesDay.report_date).format('YYYY-MM-DD'),
                    amount: Number(worstSalesDay.total_sales)
                },
                sales_trend: {
                    increasing_days: increasingDays,
                    decreasing_days: decreasingDays,
                    stable_days: stableDays
                }
            },
            filter_info: {
                type: filterType || 'month',
                value: filterValue,
                start_date: startDate,
                end_date: endDate
            },
            report_date: new Date()
        };
        
        await this.cacheService.set(cacheKey, result, 3600);
        return result;
    }

    async getSalesProgressForCharts(
        period: 'daily' | 'monthly' | 'yearly',
        filterType?: 'month' | 'year' | 'custom',
        filterValue?: string,
        startDate?: string,
        endDate?: string,
    ) {
        const cacheKey = `reports:salesProgressForCharts:${period}:${filterType}:${filterValue}:${startDate}:${endDate}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached;
        }

        let whereCondition = {};
        let groupByFormat = '';
        let orderByField = '';

        if (filterType === 'month' && filterValue) {
            const month = parseInt(filterValue);
            const currentYear = new Date().getFullYear();
            whereCondition = {
                report_date: Between(
                new Date(currentYear, month - 1, 1),
                new Date(currentYear, month, 0, 23, 59, 59)
                )
            };
        } else if (filterType === 'year' && filterValue) {
            const year = parseInt(filterValue);
            whereCondition = {
                report_date: Between(
                new Date(year, 0, 1),
                new Date(year, 11, 31, 23, 59, 59)
                )
            };
        } else if (filterType === 'custom' && startDate && endDate) {
            whereCondition = {
                report_date: Between(
                new Date(startDate + ' 00:00:00'),
                new Date(endDate + ' 23:59:59')
                )
            };
        }

        switch (period) {
        case 'daily':
            groupByFormat = 'DATE(report.report_date)';
            orderByField = 'DATE(report.report_date)';
            break;
        case 'monthly':
            groupByFormat = 'DATE_FORMAT(report.report_date, "%Y-%m")';
            orderByField = 'DATE_FORMAT(report.report_date, "%Y-%m")';
            break;
        case 'yearly':
            groupByFormat = 'YEAR(report.report_date)';
            orderByField = 'YEAR(report.report_date)';
            break;
        }

        const salesData = await this.dailyReportRepository
        .createQueryBuilder('report')
        .select([
            `${groupByFormat} as period`,
            'SUM(report.total_sales) as sales',
            'SUM(report.total_orders) as orders'
        ])
        .where(whereCondition)
        .groupBy(groupByFormat)
        .orderBy(orderByField, 'ASC')
        .getRawMany();

        const totalSales = salesData.reduce((sum, item) => sum + parseFloat(item.sales || 0), 0);
        const totalOrders = salesData.reduce((sum, item) => sum + parseInt(item.orders || 0), 0);
        const averageSales = totalSales / (salesData.length || 1);
        
        let growthRate = 0;
        if (salesData.length >= 2) {
        const firstPeriod = parseFloat(salesData[0].sales || 0);
        const lastPeriod = parseFloat(salesData[salesData.length - 1].sales || 0);
        if (firstPeriod > 0) {
            growthRate = ((lastPeriod - firstPeriod) / firstPeriod) * 100;
        }
        }

        return {
        chartData: salesData.map(item => ({
            period: item.period,
            sales: parseFloat(item.sales || 0),
            orders: parseInt(item.orders || 0)
        })),
        summary: {
            totalSales: Math.round(totalSales * 100) / 100,
            totalOrders,
            averageSales: Math.round(averageSales * 100) / 100,
            growthRate: Math.round(growthRate * 100) / 100
        }
        };
    }

    async getExpensesForCharts(
        chartType: 'line' | 'bar' | 'pie' | 'donut' = 'bar',
        period: 'day' | 'month' | 'year' = 'month',
        filterType?: 'month' | 'year' | 'custom',
        filterValue?: string,
        startDate?: string,
        endDate?: string
    ): Promise<any> {
        const cacheKey = `reports:expensesForCharts:${chartType}:${period}:${filterType}:${filterValue}:${startDate}:${endDate}`;
        const cached = await this.cacheService.get(cacheKey);
        if (cached) {
            return cached;
        }

        let whereCondition: any = {};
        let start: moment.Moment;
        let end: moment.Moment;
        
        if (filterType === 'custom' && startDate && endDate) {
            start = moment(startDate);
            end = moment(endDate);
        } else if (filterType === 'year' && filterValue) {
            start = moment(filterValue, 'YYYY').startOf('year');
            end = moment(filterValue, 'YYYY').endOf('year');
        } else if (filterType === 'month' && filterValue) {
            start = moment(filterValue, 'YYYY-MM').startOf('month');
            end = moment(filterValue, 'YYYY-MM').endOf('month');
        } else {
            start = moment().startOf('year');
            end = moment().endOf('year');
        }
        
        whereCondition = {
            created_at: Between(start.toDate(), end.toDate())
        };
        
        const expenses = await this.expensesRepository.find({
            where: whereCondition,
            relations: ['category'],
            order: { created_at: 'ASC' }
        });
        
        const periodData = new Map<string, Map<string, number>>();
        const categoryTotals = new Map<string, number>();
        
        expenses.forEach(expense => {
            let periodKey: string;
            let displayDate: string;
            
            if (period === 'day') {
                periodKey = moment(expense.created_at).format('YYYY-MM-DD');
                displayDate = moment(expense.created_at).format('MMM DD');
            } else if (period === 'month') {
                periodKey = moment(expense.created_at).format('YYYY-MM');
                displayDate = moment(expense.created_at).format('MMM YYYY');
            } else {
                periodKey = moment(expense.created_at).format('YYYY');
                displayDate = moment(expense.created_at).format('YYYY');
            }
            
            const categoryName = expense.category?.name || 'Uncategorized';
            const amount = Number(expense.amount || 0);
            
            if (!periodData.has(periodKey)) {
                periodData.set(periodKey, new Map<string, number>());
            }
            
            const periodMap = periodData.get(periodKey)!;
            periodMap.set(categoryName, (periodMap.get(categoryName) || 0) + amount);
            
            categoryTotals.set(categoryName, (categoryTotals.get(categoryName) || 0) + amount);
        });
        
        const allCategories = Array.from(categoryTotals.keys()).sort();
        const allPeriods = Array.from(periodData.keys()).sort();
        
        const categories = allPeriods.map(periodKey => {
            if (period === 'day') {
                return moment(periodKey).format('MMM DD');
            } else if (period === 'month') {
                return moment(periodKey).format('MMM YYYY');
            } else {
                return periodKey;
            }
        });
        
        const series = allCategories.map(category => ({
            name: category,
            data: allPeriods.map(periodKey => {
                const periodMap = periodData.get(periodKey);
                return Number((periodMap?.get(category) || 0).toFixed(2));
            })
        }));
        
        const totalExpenses = Array.from(categoryTotals.values()).reduce((sum, val) => sum + val, 0);
        const categoryBreakdown = Array.from(categoryTotals.entries()).map(([category, amount]) => ({
            category,
            amount: Number(amount.toFixed(2)),
            percentage: Number(((amount / totalExpenses) * 100).toFixed(2))
        })).sort((a, b) => b.amount - a.amount);
        
        const averageExpenses = allPeriods.length > 0 ? totalExpenses / allPeriods.length : 0;
        
        return {
            series,
            categories,
            categoryBreakdown,
            chart_type: chartType,
            period,
            total_expenses: Number(totalExpenses.toFixed(2)),
            average_expenses: Number(averageExpenses.toFixed(2)),
            period_info: {
                filter_type: filterType,
                filter_value: filterValue,
                start_date: startDate,
                end_date: endDate
            }
        };
    }

    @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
    async autoGenerateDailyReport(): Promise<void> {
        try {
            const yesterday = moment().tz('Asia/Dhaka').subtract(1, 'day').format('YYYY-MM-DD');
            await this.generateReport(yesterday, true);
            this.logger.log(`Auto-generated daily report for ${yesterday}`);
        } catch (error) {
            if (error instanceof ConflictException) {
                this.logger.warn(`Daily report already exists for yesterday`);
            } else {
                this.logger.error('Failed to auto-generate daily report:', error);
            }
        }
    }

    private async invalidateReportCaches(): Promise<void> {
        const patterns = [
            'reports:*',
            'dashboard:*',
            'financial-summary:*',
            'sales-progress:*',
            'expenses-charts:*'
        ];
        
        for (const pattern of patterns) {
            const keys = await this.cacheService.getKeys(pattern);
            if (keys.length > 0) {
                await this.cacheService.deleteMany(keys);
            }
        }
    }
}